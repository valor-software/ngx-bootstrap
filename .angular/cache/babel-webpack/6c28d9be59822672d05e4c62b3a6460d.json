{"ast":null,"code":"import { ChangeDetectorRef, ElementRef, EventEmitter, Renderer2, TemplateRef, ViewContainerRef } from '@angular/core';\nimport { NgControl } from '@angular/forms';\nimport { ComponentLoaderFactory } from 'ngx-bootstrap/component-loader';\nimport { EMPTY, from, isObservable } from 'rxjs';\nimport { debounceTime, filter, mergeMap, switchMap, tap, toArray } from 'rxjs/operators';\nimport { TypeaheadContainerComponent } from './typeahead-container.component';\nimport { TypeaheadMatch } from './typeahead-match.class';\nimport { getValueFromObject, latinize, tokenize } from './typeahead-utils';\nimport { TypeaheadConfig } from './typeahead.config';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"ngx-bootstrap/component-loader\";\nimport * as i2 from \"./typeahead.config\";\nimport * as i3 from \"@angular/forms\";\nexport let TypeaheadDirective = /*#__PURE__*/(() => {\n  class TypeaheadDirective {\n    constructor(cis, config, changeDetection, element, ngControl, renderer, viewContainerRef) {\n      this.changeDetection = changeDetection;\n      this.element = element;\n      this.ngControl = ngControl;\n      this.renderer = renderer;\n      /** minimal no of characters that needs to be entered before\r\n       * typeahead kicks-in. When set to 0, typeahead shows on focus with full\r\n       * list of options (limited as normal by typeaheadOptionsLimit)\r\n       */\n\n      this.typeaheadMinLength = 1;\n      /** sets use adaptive position */\n\n      this.adaptivePosition = false;\n      /** turn on/off animation */\n\n      this.isAnimated = false;\n      /** minimal wait time after last character typed before typeahead kicks-in */\n\n      this.typeaheadWaitMs = 0;\n      /** match latin symbols.\r\n       * If true the word súper would match super and vice versa.\r\n       */\n\n      this.typeaheadLatinize = true;\n      /** Can be use to search words by inserting a single white space between each characters\r\n       *  for example 'C a l i f o r n i a' will match 'California'.\r\n       */\n\n      this.typeaheadSingleWords = true;\n      /** should be used only in case typeaheadSingleWords attribute is true.\r\n       * Sets the word delimiter to break words. Defaults to space.\r\n       */\n\n      this.typeaheadWordDelimiters = ' ';\n      /** should be used only in case typeaheadMultipleSearch attribute is true.\r\n       * Sets the multiple search delimiter to know when to start a new search. Defaults to comma.\r\n       * If space needs to be used, then explicitly set typeaheadWordDelimiters to something else than space\r\n       * because space is used by default OR set typeaheadSingleWords attribute to false if you don't need\r\n       * to use it together with multiple search.\r\n       */\n\n      this.typeaheadMultipleSearchDelimiters = ',';\n      /** should be used only in case typeaheadSingleWords attribute is true.\r\n       * Sets the word delimiter to match exact phrase.\r\n       * Defaults to simple and double quotes.\r\n       */\n\n      this.typeaheadPhraseDelimiters = '\\'\"';\n      /** specifies if typeahead is scrollable  */\n\n      this.typeaheadScrollable = false;\n      /** specifies number of options to show in scroll view  */\n\n      this.typeaheadOptionsInScrollableView = 5;\n      /** fired when an options list was opened and the user clicked Tab\r\n       * If a value equal true, it will be chosen first or active item in the list\r\n       * If value equal false, it will be chosen an active item in the list or nothing\r\n       */\n\n      this.typeaheadSelectFirstItem = true;\n      /** makes active first item in a list */\n\n      this.typeaheadIsFirstItemActive = true;\n      /** fired when 'busy' state of this component was changed,\r\n       * fired on async mode only, returns boolean\r\n       */\n\n      this.typeaheadLoading = new EventEmitter();\n      /** fired on every key event and returns true\r\n       * in case of matches are not detected\r\n       */\n\n      this.typeaheadNoResults = new EventEmitter();\n      /** fired when option was selected, return object with data of this option. */\n\n      this.typeaheadOnSelect = new EventEmitter();\n      /** fired when option was previewed, return object with data of this option. */\n\n      this.typeaheadOnPreview = new EventEmitter();\n      /** fired when blur event occurs. returns the active item */\n\n      this.typeaheadOnBlur = new EventEmitter();\n      /** This attribute indicates that the dropdown should be opened upwards */\n\n      this.dropup = false;\n      this.isOpen = false;\n      this.list = 'list';\n      this.isActiveItemChanged = false;\n      this.isFocused = false;\n      this.cancelRequestOnFocusLost = false;\n      this.selectItemOnBlur = false;\n      this.keyUpEventEmitter = new EventEmitter();\n      this.placement = 'bottom left';\n      this._matches = [];\n      this._subscriptions = [];\n\n      this._outsideClickListener = () => void 0;\n\n      this._typeahead = cis.createLoader(element, viewContainerRef, renderer).provide({\n        provide: TypeaheadConfig,\n        useValue: config\n      });\n      Object.assign(this, {\n        typeaheadHideResultsOnBlur: config.hideResultsOnBlur,\n        cancelRequestOnFocusLost: config.cancelRequestOnFocusLost,\n        typeaheadSelectFirstItem: config.selectFirstItem,\n        typeaheadIsFirstItemActive: config.isFirstItemActive,\n        typeaheadMinLength: config.minLength,\n        adaptivePosition: config.adaptivePosition,\n        isAnimated: config.isAnimated,\n        selectItemOnBlur: config.selectItemOnBlur\n      });\n    }\n\n    get matches() {\n      return this._matches;\n    }\n\n    ngOnInit() {\n      this.typeaheadOptionsLimit = this.typeaheadOptionsLimit || 20;\n      this.typeaheadMinLength = this.typeaheadMinLength === void 0 ? 1 : this.typeaheadMinLength; // async should be false in case of array\n\n      if (this.typeaheadAsync === undefined && !isObservable(this.typeahead)) {\n        this.typeaheadAsync = false;\n      }\n\n      if (isObservable(this.typeahead)) {\n        this.typeaheadAsync = true;\n      }\n\n      if (this.typeaheadAsync) {\n        this.asyncActions();\n      } else {\n        this.syncActions();\n      }\n\n      this.checkDelimitersConflict();\n    } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n    onInput(e) {\n      // For `<input>`s, use the `value` property. For others that don't have a\n      // `value` (such as `<span contenteditable=\"true\">`), use either\n      // `textContent` or `innerText` (depending on which one is supported, i.e.\n      // Firefox or IE).\n      const value = e.target.value !== undefined ? e.target.value : e.target.textContent !== undefined ? e.target.textContent : e.target.innerText;\n\n      if (value != null && value.trim().length >= this.typeaheadMinLength) {\n        this.typeaheadLoading.emit(true);\n        this.keyUpEventEmitter.emit(e.target.value);\n      } else {\n        this.typeaheadLoading.emit(false);\n        this.typeaheadNoResults.emit(false);\n        this.hide();\n      }\n    }\n\n    onChange(event) {\n      if (this._container) {\n        // esc\n        if (event.keyCode === 27 || event.key === 'Escape') {\n          this.hide();\n          return;\n        } // up\n\n\n        if (event.keyCode === 38 || event.key === 'ArrowUp') {\n          this.isActiveItemChanged = true;\n\n          this._container.prevActiveMatch();\n\n          return;\n        } // down\n\n\n        if (event.keyCode === 40 || event.key === 'ArrowDown') {\n          this.isActiveItemChanged = true;\n\n          this._container.nextActiveMatch();\n\n          return;\n        } // enter\n\n\n        if (event.keyCode === 13 || event.key === 'Enter') {\n          this._container.selectActiveMatch();\n\n          return;\n        }\n      }\n    }\n\n    onFocus() {\n      this.isFocused = true; // add setTimeout to fix issue #5251\n      // to get and emit updated value if it's changed on focus\n\n      setTimeout(() => {\n        if (this.typeaheadMinLength === 0) {\n          this.typeaheadLoading.emit(true);\n          this.keyUpEventEmitter.emit(this.element.nativeElement.value || '');\n        }\n      }, 0);\n    }\n\n    onBlur() {\n      var _a;\n\n      this.isFocused = false;\n\n      if (this._container && !this._container.isFocused) {\n        this.typeaheadOnBlur.emit(this._container.active);\n      }\n\n      if (!this.container && ((_a = this._matches) === null || _a === void 0 ? void 0 : _a.length) === 0) {\n        this.typeaheadOnBlur.emit(new TypeaheadMatch(this.element.nativeElement.value, this.element.nativeElement.value, false));\n      }\n    }\n\n    onKeydown(event) {\n      // no container - no problems\n      if (!this._container) {\n        return;\n      }\n\n      if (event.keyCode === 9 || event.key === 'Tab') {\n        this.onBlur();\n      }\n\n      if (event.keyCode === 9 || event.key === 'Tab' || event.keyCode === 13 || event.key === 'Enter') {\n        event.preventDefault();\n\n        if (this.typeaheadSelectFirstItem) {\n          this._container.selectActiveMatch();\n\n          return;\n        }\n\n        if (!this.typeaheadSelectFirstItem) {\n          this._container.selectActiveMatch(this.isActiveItemChanged);\n\n          this.isActiveItemChanged = false;\n          this.hide();\n        }\n      }\n    }\n\n    changeModel(match) {\n      var _a;\n\n      if (!match) {\n        return;\n      }\n\n      let valueStr;\n\n      if (this.typeaheadMultipleSearch && this._allEnteredValue) {\n        const tokens = this._allEnteredValue.split(new RegExp(`([${this.typeaheadMultipleSearchDelimiters}]+)`));\n\n        this._allEnteredValue = tokens.slice(0, tokens.length - 1).concat(match.value).join('');\n        valueStr = this._allEnteredValue;\n      } else {\n        valueStr = match.value;\n      }\n\n      this.ngControl.viewToModelUpdate(valueStr);\n      (_a = this.ngControl.control) === null || _a === void 0 ? void 0 : _a.setValue(valueStr);\n      this.changeDetection.markForCheck();\n      this.hide();\n    }\n\n    show() {\n      this._typeahead.attach(TypeaheadContainerComponent).to(this.container).position({\n        attachment: `${this.dropup ? 'top' : 'bottom'} left`\n      }).show({\n        typeaheadRef: this,\n        placement: this.placement,\n        animation: false,\n        dropup: this.dropup\n      });\n\n      this._outsideClickListener = this.renderer.listen('document', 'click', event => {\n        if (this.typeaheadMinLength === 0 && this.element.nativeElement.contains(event.target)) {\n          return;\n        }\n\n        if (!this.typeaheadHideResultsOnBlur || this.element.nativeElement.contains(event.target)) {\n          return;\n        }\n\n        this.onOutsideClick();\n      });\n\n      if (!this._typeahead.instance || !this.ngControl.control) {\n        return;\n      }\n\n      this._container = this._typeahead.instance;\n      this._container.parent = this; // This improves the speed as it won't have to be done for each list item\n\n      const normalizedQuery = (this.typeaheadLatinize ? latinize(this.ngControl.control.value) : this.ngControl.control.value).toString().toLowerCase();\n      this._container.query = this.tokenizeQuery(normalizedQuery);\n      this._container.matches = this._matches;\n      this.element.nativeElement.focus();\n\n      this._container.activeChangeEvent.subscribe(activeId => {\n        this.activeDescendant = activeId;\n        this.changeDetection.markForCheck();\n      });\n\n      this.isOpen = true;\n    }\n\n    hide() {\n      if (this._typeahead.isShown) {\n        this._typeahead.hide();\n\n        this._outsideClickListener();\n\n        this._container = void 0;\n        this.isOpen = false;\n        this.changeDetection.markForCheck();\n      }\n\n      this.typeaheadOnPreview.emit();\n    }\n\n    onOutsideClick() {\n      if (this._container && !this._container.isFocused) {\n        this.hide();\n      }\n    }\n\n    ngOnDestroy() {\n      // clean up subscriptions\n      for (const sub of this._subscriptions) {\n        sub.unsubscribe();\n      }\n\n      this._typeahead.dispose();\n    }\n\n    asyncActions() {\n      this._subscriptions.push(this.keyUpEventEmitter.pipe(debounceTime(this.typeaheadWaitMs), tap(value => this._allEnteredValue = value), switchMap(() => {\n        if (!this.typeahead) {\n          return EMPTY;\n        }\n\n        return this.typeahead;\n      })).subscribe(matches => {\n        this.finalizeAsyncCall(matches);\n      }));\n    }\n\n    syncActions() {\n      this._subscriptions.push(this.keyUpEventEmitter.pipe(debounceTime(this.typeaheadWaitMs), mergeMap(value => {\n        this._allEnteredValue = value;\n        const normalizedQuery = this.normalizeQuery(value);\n\n        if (!this.typeahead) {\n          return EMPTY;\n        }\n\n        const typeahead = isObservable(this.typeahead) ? this.typeahead : from(this.typeahead);\n        return typeahead.pipe(filter(option => {\n          return !!option && this.testMatch(this.normalizeOption(option), normalizedQuery);\n        }), toArray());\n      })).subscribe(matches => {\n        this.finalizeAsyncCall(matches);\n      }));\n    }\n\n    normalizeOption(option) {\n      const optionValue = getValueFromObject(option, this.typeaheadOptionField);\n      const normalizedOption = this.typeaheadLatinize ? latinize(optionValue) : optionValue;\n      return normalizedOption.toLowerCase();\n    }\n\n    tokenizeQuery(currentQuery) {\n      let query = currentQuery;\n\n      if (this.typeaheadMultipleSearch && this.typeaheadSingleWords) {\n        if (!this.haveCommonCharacters(`${this.typeaheadPhraseDelimiters}${this.typeaheadWordDelimiters}`, this.typeaheadMultipleSearchDelimiters)) {\n          // single words and multiple search delimiters are different, can be used together\n          query = tokenize(query, this.typeaheadWordDelimiters, this.typeaheadPhraseDelimiters, this.typeaheadMultipleSearchDelimiters);\n        }\n      } else if (this.typeaheadSingleWords) {\n        query = tokenize(query, this.typeaheadWordDelimiters, this.typeaheadPhraseDelimiters);\n      } else {\n        // multiple searches\n        query = tokenize(query, void 0, void 0, this.typeaheadMultipleSearchDelimiters);\n      }\n\n      return query;\n    }\n\n    normalizeQuery(value) {\n      // If singleWords, break model here to not be doing extra work on each iteration\n      let normalizedQuery = (this.typeaheadLatinize ? latinize(value) : value).toString().toLowerCase();\n      normalizedQuery = this.tokenizeQuery(normalizedQuery);\n      return normalizedQuery;\n    }\n\n    testMatch(match, test) {\n      let spaceLength;\n\n      if (typeof test === 'object') {\n        spaceLength = test.length;\n\n        for (let i = 0; i < spaceLength; i += 1) {\n          if (test[i].length > 0 && match.indexOf(test[i]) < 0) {\n            return false;\n          }\n        }\n\n        return true;\n      }\n\n      return match.indexOf(test) >= 0;\n    }\n\n    finalizeAsyncCall(matches) {\n      this.prepareMatches(matches || []);\n      this.typeaheadLoading.emit(false);\n      this.typeaheadNoResults.emit(!this.hasMatches());\n\n      if (!this.hasMatches()) {\n        this.hide();\n        return;\n      }\n\n      if (!this.isFocused && this.cancelRequestOnFocusLost) {\n        return;\n      }\n\n      if (this._container && this.ngControl.control) {\n        // fix: remove usage of ngControl internals\n        const _controlValue = (this.typeaheadLatinize ? latinize(this.ngControl.control.value) : this.ngControl.control.value) || ''; // This improves the speed as it won't have to be done for each list item\n\n\n        const normalizedQuery = _controlValue.toString().toLowerCase();\n\n        this._container.query = this.tokenizeQuery(normalizedQuery);\n        this._container.matches = this._matches;\n      } else {\n        this.show();\n      }\n    }\n\n    prepareMatches(options) {\n      const limited = options.slice(0, this.typeaheadOptionsLimit);\n      const sorted = !this.typeaheadOrderBy ? limited : this.orderMatches(limited);\n\n      if (this.typeaheadGroupField) {\n        let matches = []; // extract all group names\n\n        const groups = sorted.map(option => getValueFromObject(option, this.typeaheadGroupField)).filter((v, i, a) => a.indexOf(v) === i);\n        groups.forEach(group => {\n          // add group header to array of matches\n          matches.push(new TypeaheadMatch(group, group, true)); // add each item of group to array of matches\n\n          matches = matches.concat(sorted.filter(option => getValueFromObject(option, this.typeaheadGroupField) === group).map(option => new TypeaheadMatch(option, getValueFromObject(option, this.typeaheadOptionField))));\n        });\n        this._matches = matches;\n      } else {\n        this._matches = sorted.map( // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        option => new TypeaheadMatch(option, getValueFromObject(option, this.typeaheadOptionField)));\n      }\n    }\n\n    orderMatches(options) {\n      if (!options.length) {\n        return options;\n      }\n\n      if (this.typeaheadOrderBy !== null && this.typeaheadOrderBy !== undefined && typeof this.typeaheadOrderBy === 'object' && Object.keys(this.typeaheadOrderBy).length === 0) {\n        console.error('Field and direction properties for typeaheadOrderBy have to be set according to documentation!');\n        return options;\n      }\n\n      const {\n        field,\n        direction\n      } = this.typeaheadOrderBy || {};\n\n      if (!direction || !(direction === 'asc' || direction === 'desc')) {\n        console.error('typeaheadOrderBy direction has to equal \"asc\" or \"desc\". Please follow the documentation.');\n        return options;\n      }\n\n      if (typeof options[0] === 'string') {\n        return direction === 'asc' ? options.sort() : options.sort().reverse();\n      }\n\n      if (!field || typeof field !== 'string') {\n        console.error('typeaheadOrderBy field has to set according to the documentation.');\n        return options;\n      }\n\n      return options.sort((a, b) => {\n        const stringA = getValueFromObject(a, field);\n        const stringB = getValueFromObject(b, field);\n\n        if (stringA < stringB) {\n          return direction === 'asc' ? -1 : 1;\n        }\n\n        if (stringA > stringB) {\n          return direction === 'asc' ? 1 : -1;\n        }\n\n        return 0;\n      });\n    }\n\n    hasMatches() {\n      return this._matches.length > 0;\n    }\n\n    checkDelimitersConflict() {\n      if (this.typeaheadMultipleSearch && this.typeaheadSingleWords && this.haveCommonCharacters(`${this.typeaheadPhraseDelimiters}${this.typeaheadWordDelimiters}`, this.typeaheadMultipleSearchDelimiters)) {\n        throw new Error(`Delimiters used in typeaheadMultipleSearchDelimiters must be different\n          from delimiters used in typeaheadWordDelimiters (current value: ${this.typeaheadWordDelimiters}) and\n          typeaheadPhraseDelimiters (current value: ${this.typeaheadPhraseDelimiters}).\n          Please refer to the documentation`);\n      }\n    }\n\n    haveCommonCharacters(str1, str2) {\n      for (let i = 0; i < str1.length; i++) {\n        if (str1.charAt(i).indexOf(str2) > -1) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n  }\n\n  TypeaheadDirective.ɵfac = function TypeaheadDirective_Factory(t) {\n    return new (t || TypeaheadDirective)(i0.ɵɵdirectiveInject(i1.ComponentLoaderFactory), i0.ɵɵdirectiveInject(i2.TypeaheadConfig), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i3.NgControl), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ViewContainerRef));\n  };\n\n  TypeaheadDirective.ɵdir = /*@__PURE__*/i0.ɵɵdefineDirective({\n    type: TypeaheadDirective,\n    selectors: [[\"\", \"typeahead\", \"\"]],\n    hostVars: 4,\n    hostBindings: function TypeaheadDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"input\", function TypeaheadDirective_input_HostBindingHandler($event) {\n          return ctx.onInput($event);\n        })(\"keyup\", function TypeaheadDirective_keyup_HostBindingHandler($event) {\n          return ctx.onChange($event);\n        })(\"click\", function TypeaheadDirective_click_HostBindingHandler() {\n          return ctx.onFocus();\n        })(\"focus\", function TypeaheadDirective_focus_HostBindingHandler() {\n          return ctx.onFocus();\n        })(\"blur\", function TypeaheadDirective_blur_HostBindingHandler() {\n          return ctx.onBlur();\n        })(\"keydown\", function TypeaheadDirective_keydown_HostBindingHandler($event) {\n          return ctx.onKeydown($event);\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵattribute(\"aria-activedescendant\", ctx.activeDescendant)(\"aria-owns\", ctx.isOpen ? ctx._container.popupId : null)(\"aria-expanded\", ctx.isOpen)(\"aria-autocomplete\", ctx.list);\n      }\n    },\n    inputs: {\n      typeahead: \"typeahead\",\n      typeaheadMinLength: \"typeaheadMinLength\",\n      adaptivePosition: \"adaptivePosition\",\n      isAnimated: \"isAnimated\",\n      typeaheadWaitMs: \"typeaheadWaitMs\",\n      typeaheadOptionsLimit: \"typeaheadOptionsLimit\",\n      typeaheadOptionField: \"typeaheadOptionField\",\n      typeaheadGroupField: \"typeaheadGroupField\",\n      typeaheadOrderBy: \"typeaheadOrderBy\",\n      typeaheadAsync: \"typeaheadAsync\",\n      typeaheadLatinize: \"typeaheadLatinize\",\n      typeaheadSingleWords: \"typeaheadSingleWords\",\n      typeaheadWordDelimiters: \"typeaheadWordDelimiters\",\n      typeaheadMultipleSearch: \"typeaheadMultipleSearch\",\n      typeaheadMultipleSearchDelimiters: \"typeaheadMultipleSearchDelimiters\",\n      typeaheadPhraseDelimiters: \"typeaheadPhraseDelimiters\",\n      typeaheadItemTemplate: \"typeaheadItemTemplate\",\n      optionsListTemplate: \"optionsListTemplate\",\n      typeaheadScrollable: \"typeaheadScrollable\",\n      typeaheadOptionsInScrollableView: \"typeaheadOptionsInScrollableView\",\n      typeaheadHideResultsOnBlur: \"typeaheadHideResultsOnBlur\",\n      typeaheadSelectFirstItem: \"typeaheadSelectFirstItem\",\n      typeaheadIsFirstItemActive: \"typeaheadIsFirstItemActive\",\n      container: \"container\",\n      dropup: \"dropup\"\n    },\n    outputs: {\n      typeaheadLoading: \"typeaheadLoading\",\n      typeaheadNoResults: \"typeaheadNoResults\",\n      typeaheadOnSelect: \"typeaheadOnSelect\",\n      typeaheadOnPreview: \"typeaheadOnPreview\",\n      typeaheadOnBlur: \"typeaheadOnBlur\"\n    },\n    exportAs: [\"bs-typeahead\"]\n  });\n  return TypeaheadDirective;\n})();","map":null,"metadata":{},"sourceType":"module"}