{"version":3,"sources":["../../../.tmp/chronos/moment/min-max.ts"],"names":[],"mappings":"AAAA,oEAAoE;AACpE,0DAA0D;AAC1D,EAAE;AACF,yEAAyE;AACzE,+CAA+C;AAC/C,OAAO,EAAE,OAAO,EAAE,WAAW,EAAE,MAAM,sBAAsB,CAAC;AAC5D,OAAO,EAAE,OAAO,EAAE,QAAQ,EAAE,MAAM,uBAAuB,CAAC;AAE1D,gBAAgB,EAAY,EAAE,KAAwB;IACpD,IAAI,MAAc,CAAC;IACnB,IAAM,SAAS,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;IAC3B,EAAE,CAAC,CAAC,OAAO,CAAO,SAAS,CAAC,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,CAAC,CAAC,CAAC;QACnD,MAAM,GAAG,SAAS,CAAC;IACrB,CAAC;IAAC,IAAI,CAAC,EAAE,CAAC,CAAC,OAAO,CAAO,KAAK,CAAC,CAAC,CAAC,CAAC;QAChC,MAAM,GAAG,KAAK,CAAC;IACjB,CAAC;IAED,EAAE,CAAC,CAAC,CAAC,MAAM,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC;QAC9B,MAAM,CAAC,IAAI,IAAI,EAAE,CAAC;IACpB,CAAC;IACD,IAAI,GAAG,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;IACpB,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,MAAM,EAAE,EAAE,CAAC,EAAE,CAAC;QACvC,sDAAsD;QACtD,EAAE,CAAC,CAAC,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC,IAAI,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC;YAC7D,GAAG,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;QAClB,CAAC;IACH,CAAC;IAED,MAAM,CAAC,GAAG,CAAC;AACb,CAAC;AAED,6BAA6B;AAC7B,MAAM;IACJ,4CAA4C;IAD1B,cAAe;SAAf,UAAe,EAAf,qBAAe,EAAf,IAAe;QAAf,yBAAe;;IAGjC,MAAM,CAAC,MAAM,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;AAChC,CAAC;AAED,MAAM;IACJ,4CAA4C;IAD1B,cAAe;SAAf,UAAe,EAAf,qBAAe,EAAf,IAAe;QAAf,yBAAe;;IAGjC,MAAM,CAAC,MAAM,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;AAC/B,CAAC","file":"min-max.js","sourceRoot":"","sourcesContent":["// Pick a moment m from moments so that m[fn](other) is true for all\r\n// other. This relies on the function fn to be transitive.\r\n//\r\n// moments should either be an array of moment objects or an array, whose\r\n// first element is an array of moment objects.\r\nimport { isArray, isDateValid } from '../utils/type-checks';\r\nimport { isAfter, isBefore } from '../utils/date-compare';\r\n\r\nfunction pickBy(fn: Function, dates: Date[] | Date[][]): Date {\r\n  let _dates: Date[];\r\n  const _firstArg = dates[0];\r\n  if (isArray<Date>(_firstArg) && dates.length === 1) {\r\n    _dates = _firstArg;\r\n  } else if (isArray<Date>(dates)) {\r\n    _dates = dates;\r\n  }\r\n\r\n  if (!_dates || !_dates.length) {\r\n    return new Date();\r\n  }\r\n  let res = _dates[0];\r\n  for (let i = 1; i < _dates.length; ++i) {\r\n    // if (!moments[i].isValid() || moments[i][fn](res)) {\r\n    if (!isDateValid(_dates[i]) || fn.call(null, _dates[i], res)) {\r\n      res = _dates[i];\r\n    }\r\n  }\r\n\r\n  return res;\r\n}\r\n\r\n// TODO: Use [].sort instead?\r\nexport function min(...args: Date[]): Date {\r\n  // const args = [].slice.call(arguments, 0);\r\n\r\n  return pickBy(isBefore, args);\r\n}\r\n\r\nexport function max(...args: Date[]): Date {\r\n  // const args = [].slice.call(arguments, 0);\r\n\r\n  return pickBy(isAfter, args);\r\n}\r\n"]}