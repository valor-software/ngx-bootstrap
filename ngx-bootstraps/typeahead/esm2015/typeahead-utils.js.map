{"version":3,"file":"typeahead-utils.js","sourceRoot":"","sources":["../../../src/typeahead/typeahead-utils.ts"],"names":[],"mappings":"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","sourcesContent":["import { latinMap } from './latin-map';\n\nexport function latinize(str: string): string {\n  if (!str) {\n    return '';\n  }\n\n  return str.replace(/[^A-Za-z0-9\\[\\] ]/g, function (a: string): string {\n    return latinMap[a] || a;\n  });\n}\n\nexport function escapeRegexp(queryToEscape: string): string {\n  // Regex: capture the whole query string and replace it with the string\n  // that will be used to match the results, for example if the capture is\n  // 'a' the result will be \\a\n  return queryToEscape.replace(/([.?*+^$[\\]\\\\(){}|-])/g, '\\\\$1');\n}\n\n/* tslint:disable */\nexport function tokenize(str: string,\n  wordRegexDelimiters = ' ',\n  phraseRegexDelimiters = '', delimitersForMultipleSearch?: string): Array<string> {\n\n  let result: string[] = [];\n  if (!delimitersForMultipleSearch) {\n    result = tokenizeWordsAndPhrases(str, wordRegexDelimiters, phraseRegexDelimiters);\n  } else {\n    const multipleSearchRegexStr = `([${delimitersForMultipleSearch}]+)`;\n    const delimitedTokens = str.split(new RegExp(multipleSearchRegexStr, 'g'));\n    const lastToken = delimitedTokens[delimitedTokens.length - 1];\n    if (lastToken > '') {\n      if (wordRegexDelimiters && phraseRegexDelimiters) {\n        result = tokenizeWordsAndPhrases(lastToken, wordRegexDelimiters, phraseRegexDelimiters);\n      } else {\n        result.push(lastToken);\n      }\n    }\n  }\n\n  return result;\n}\n\nfunction tokenizeWordsAndPhrases(str: string, wordRegexDelimiters: string, phraseRegexDelimiters: string): Array<string> {\n  const result: string[] = [];\n  /* tslint:enable */\n  const regexStr = `(?:[${phraseRegexDelimiters}])([^${phraseRegexDelimiters}]+)` +\n  `(?:[${phraseRegexDelimiters}])|([^${wordRegexDelimiters}]+)`;\n  const preTokenized: string[] = str.split(new RegExp(regexStr, 'g'));\n  const preTokenizedLength: number = preTokenized.length;\n  let token: string;\n  const replacePhraseDelimiters = new RegExp(`[${phraseRegexDelimiters}]+`, 'g');\n\n  for (let i = 0; i < preTokenizedLength; i += 1) {\n    token = preTokenized[i];\n    if (token && token.length && token !== wordRegexDelimiters) {\n      result.push(token.replace(replacePhraseDelimiters, ''));\n    }\n  }\n\n  return result;\n}\n\n// tslint:disable-next-line:no-any\nexport function getValueFromObject(object: any, option: string): string {\n  if (!option || typeof object !== 'object') {\n    return object.toString();\n  }\n\n  if (option.endsWith('()')) {\n    const functionName = option.slice(0, option.length - 2);\n\n    return object[functionName]().toString();\n  }\n\n  const properties: string = option\n    .replace(/\\[(\\w+)\\]/g, '.$1')\n    .replace(/^\\./, '');\n  const propertiesArray: string[] = properties.split('.');\n\n  for (const property of propertiesArray) {\n    if (property in object) {\n      // tslint:disable-next-line\n      object = object[property];\n    }\n  }\n  if (!object) {return ''; }\n\n  return object.toString();\n}\n"]}